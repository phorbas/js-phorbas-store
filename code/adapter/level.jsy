import { _bkc_storage_, bkc_arrbuf } from '../bkc_abstract.jsy'

export {bkc_arrbuf}

export default bkc_with_level
export async function bkc_with_level(levelup, opt={}) ::
  const immutable = !! opt.immutable
  const lvl_opt = @{}
    keyEncoding: 'utf8',
    valueEncoding: 'binary',
    ...opt.level_options

  return _bkc_storage_.with @:
    bkc_opt: @{} immutable

    async bkc_exists(hexkey) ::
      try ::
        let res = await levelup.get(hexkey, lvl_opt)
        return null == res ? 0 : 1

      catch err ::
        if ! err.notFound :: throw err
        return 0

    async bkc_fetch(hexkey) ::
      try ::
        let buf = await levelup.get(hexkey, lvl_opt)
        return !buf ? void buf
          : new Uint8Array(buf).buffer 
      catch err ::
        if ! err.notFound :: throw err

    async bkc_store(hexkey, body) ::
      if immutable ::
        try ::
          let res = await levelup.get(hexkey, lvl_opt)
          if null != res :: return false
        catch err ::
          if ! err.notFound :: throw err

      try ::
        body = await bkc_arrbuf(body)
        await levelup.put(hexkey, Buffer.from(body), lvl_opt)
        return null
      catch err ::
        return err

    /*
    async * bkc_stream_store(hexkey_body_iter) ::
      // TODO: update to batching storage
      const ans = [], ops = []

      const {keyEncoding, valueEncoding} = lvl_opt
      for let [u8_key, u8_content] of u8_pair_list ::
        ans.push @# u8_key
        ops.push @: type:'put',
          key: as_hex_key(u8_key), keyEncoding,
          value: Buffer.from(u8_content), valueEncoding,

      try ::
        await levelup.batch(ops)
      catch err ::
        for const tpl of ans ::
          tpl[1] = err
      return ans
    */
