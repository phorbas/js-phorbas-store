import { bkc_arrbuf, bkc_rec_tools } from '../core.jsy'
import { _bkc_storage_ } from '../abstract/bkc_abstract_single.jsy'

export * from '../core.jsy'

let _bkc_multi_lite
export function bkc_multi(opt={}) ::
  _bkc_multi_lite ??= _bkc_storage_.with(_bkc_multi_mixin_)
  return _bkc_multi_with(_bkc_multi_lite, opt)

export default bkc_multi


export async function _bkc_multi_with(_bkc_multi_, opt) ::
  if 'function' === typeof opt :: opt = {bkc_lookup: opt}

  return _bkc_multi_.with @:
    bkc_opt: @{} proxy: true
    _xf_decode_body: opt.decode_body
    _xf_lookup: _bkc_multi_lookup(opt.bkc_lookup, opt.encode_body, opt.stg_tgt)


export function _bkc_multi_lookup(bkc_lookup_fn, _xf_encode_body, stg_default) ::
  return rec => ::
    rec.stg = stg_default
    rec.stg = bkc_lookup_fn?.(rec, bkc_rec_tools) ?? rec.stg
    if rec[1] ::
      rec[1] = bkc_arrbuf(rec[1])
      if _xf_encode_body ::
        rec[1] = _xf_encode_body(rec[1], rec)
    return rec


export const _bkc_multi_mixin_ = @{}
  async bkc_store(key, body, kw) ::
    let rec = this._xf_lookup([key, body])
    return (await rec.stg).bkc_store(rec[0], rec[1], kw)

  async bkc_exists(key, kw) ::
    let rec = this._xf_lookup([key])
    return (await rec.stg).bkc_exists(rec[0], kw)

  async bkc_fetch(key, kw) ::
    let rec = this._xf_lookup([key])
    let body = (await rec.stg).bkc_fetch(rec[0], kw)
    let _xf_xform = this._xf_decode_body
    return _xf_xform ? _xf_xform(body) : body

