import { bkc_arrbuf, bkc_storage_verify } from '../core.jsy'
import { _bkc_storage_ } from '../abstract/bkc_abstract_single.jsy'

export * from '../core.jsy'

export function bkc_channel_pair(stg_tgt, opt={}) ::
  let channel = new MessageChannel()
  return @{}
    channel
    bkc_send: bkc_channel_send(channel.port1, opt)
    bkc_recv: bkc_channel_recv(channel.port2, stg_tgt)


export async function bkc_channel_recv(recv_port, stg_tgt) ::
  stg_tgt = await bkc_storage_verify(stg_tgt)

  recv_port.onmessage = async (evt) => ::
    let {id, op, args} = evt.data
    try ::
      if ! /^bkc_/.test(op) :: throw new Error(`Invalid op "${op}"`)
      let ans = await stg_tgt[op](...args)
      evt.target.postMessage @: id, ans

    catch err ::
      evt.target.postMessage @: id, err: ''+err

  stg_tgt.close_port = () => recv_port.close()
  recv_port.unref?.()
  return stg_tgt


export async function bkc_channel_send(port, opt) ::
  let by_id = opt?.by_id ?? new Map()
  let n36=opt?.idx0 || 0, prefix = opt?.prefix ?? '&'

  port.onmessage = (evt) => ::
    let {id, ans, err, batch} = evt.data
    let defer = by_id.get(id)
    if err :: defer?.reject(err)
    else defer?.resolve(ans)
  
  return _bkc_storage_.with @:
    bkc_opt: @{} proxy: true
    close_port() :: return port.close()

    async bkc_exists(hexkey) ::
      return _rpc @ 'bkc_exists', hexkey

    async bkc_fetch(hexkey) ::
      return _rpc @ 'bkc_fetch', hexkey

    async bkc_store(hexkey, body) ::
      return _rpc @ 'bkc_store', hexkey, body = await bkc_arrbuf(body)

  async function _rpc(op, ... args) ::
    let id = prefix + (n36++).toString(36)
    let defer = Promise.withResolvers()
    by_id.set(id, defer)
    try ::
      port.postMessage @: id, op, args
      return await defer.promise
    finally ::
      by_id.delete(id)

