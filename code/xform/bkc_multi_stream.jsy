import { bkc_arrbuf, bkc_batch_stream  } from '../core.jsy'
import { _bkc_storage_mixin_ } from '../abstract/bkc_abstract.jsy'
import { _bkc_multi_mixin_, _bkc_multi_with } from './bkc_multi.jsy'

export * from '../core.jsy'

let _bkc_multi_stream_
export function bkc_multi_stream(opt={}) ::
  _bkc_multi_stream_ ??= _bkc_storage_mixin_.with(_bkc_multi_stream_mixin_)
  return _bkc_multi_with(_bkc_multi_stream_, opt)

export default bkc_multi_stream


const _by_stg = o => o.stg
export const _bkc_multi_stream_mixin_ = @{}
  ... _bkc_multi_mixin_

  async * bkc_stream_store(hexkey_body_aiter, kw) ::
    for await let multi_batch of bkc_batch_stream(hexkey_body_aiter, this._xf_lookup, kw) ::
      if kw?.signal?.aborted :: return

      // parallel query by storage backend
      multi_batch = Array.from @ Map.groupBy(multi_batch, _by_stg),
        async ([stg, stg_batch]) =>
          (await stg).bkc_stream_store(stg_batch, kw)

      for await let batch of this._multi_batch_merge(multi_batch, kw) ::
        if kw?.signal?.aborted :: return
        yield _decode_key_batch(batch)

  async * bkc_stream_exists(hexkey_aiter, kw) ::
    for await let multi_batch of bkc_batch_stream(hexkey_aiter, this._xf_lookup, kw) ::
      if kw?.signal?.aborted :: return

      // parallel query by storage backend
      multi_batch = Array.from @ Map.groupBy(multi_batch, _by_stg),
        async ([stg, stg_batch]) =>
          (await stg).bkc_stream_exists(stg_batch, kw)

      for await let batch of this._multi_batch_merge(multi_batch, kw) ::
        if kw?.signal?.aborted :: return
        yield _decode_key_batch(batch)

  async * bkc_stream_fetch(hexkey_aiter, kw) ::
    ::
      let xform = kw?.xform, _xf_decode_body = this._xf_decode_body
      var _xf_xform = xform && _xf_decode_body
        ? body => xform(_xf_decode_body(body))
        : xform || _xf_decode_body

      kw = {... kw, xform: null}

    for await let multi_batch of bkc_batch_stream(hexkey_aiter, this._xf_lookup, kw) ::
      if kw?.signal?.aborted :: return

      // parallel query by storage backend
      multi_batch = Array.from @ Map.groupBy(multi_batch, _by_stg),
        async ([stg, stg_batch]) =>
          (await stg).bkc_stream_fetch(stg_batch, kw)

      for await let batch of this._multi_batch_merge(multi_batch, kw) ::
        if kw?.signal?.aborted :: return

        if _xf_xform ::
          for let rec of batch ::
            rec[1] = _xf_xform(rec[1])

        yield _decode_key_batch(batch)

  async * _multi_batch_merge(multi_streams, kw) ::
    const signal = kw?.signal
    for let batch_stream of multi_streams ::
      yield * await batch_stream
      if signal?.aborted :: return


function _decode_key_batch(batch) ::
  for let rec of batch ::
    if rec.length > 2 ::
      rec[0] = rec[2]
      rec.length = 2
  return batch

