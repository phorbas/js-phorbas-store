import {u8_to_hex} from 'u8-utils'
export {u8_to_hex, hex_to_u8, utf8_to_u8, u8_to_utf8} from 'u8-utils'


const _wm_hex_cache = new WeakMap()
export function as_hex(u8_key) ::
  if 'string' === typeof u8_key ::
    throw new TypeError()

  let hk = _wm_hex_cache.get(u8_key)
  if undefined === hk ::
    hk = u8_to_hex(u8_key)
    _wm_hex_cache.set(u8_key, hk)
  return hk


export const bkc_hexkey_api = api => @:
    async bkc_exists(u8_key_list) ::
      const ans = []
      for let u8_key of u8_key_list ::
        ans.push @# u8_key,
          api.hk_has @ as_hex(u8_key)

      for const tpl of ans ::
        tpl[1] = await tpl[1]
      return ans

    async bkc_fetch(u8_key_list) ::
      const ans = []
      for let u8_key of u8_key_list ::
        ans.push @# u8_key,
          api.hk_get @ as_hex(u8_key)

      for const tpl of ans ::
        tpl[1] = await tpl[1]
      return ans

    async bkc_store(u8_pair_list) ::
      const ans = []
      for let [u8_key, u8_content] of u8_pair_list ::
        ans.push @# u8_key,
          api.hk_set @ as_hex(u8_key), u8_content

      for const tpl of ans ::
        tpl[1] = await tpl[1]
      return ans


export const bkc_binkey_api = api => @:
    async bkc_exists(u8_key_list) ::
      const ans = []
      for let u8_key of u8_key_list ::
        ans.push @# u8_key,
          api.bk_has(u8_key)

      for const tpl of ans ::
        tpl[1] = await tpl[1]
      return ans

    async bkc_fetch(u8_key_list) ::
      const ans = []
      for let u8_key of u8_key_list ::
        ans.push @# u8_key,
          api.bk_get(u8_key)

      for const tpl of ans ::
        tpl[1] = await tpl[1]
      return ans

    async bkc_store(u8_pair_list) ::
      const ans = []
      for let [u8_key, u8_content] of u8_pair_list ::
        ans.push @# u8_key,
          api.bk_set @ u8_key, u8_content

      for const tpl of ans ::
        tpl[1] = await tpl[1]
      return ans

