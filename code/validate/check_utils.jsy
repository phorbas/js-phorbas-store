import {expect} from 'chai'

import {u8_to_hex} from 'u8-utils'
import {bkc_arrbuf} from '../bkc_abstract.jsy'


export const _rand_u8 = n => globalThis.crypto.getRandomValues(new Uint8Array(n))
export const _rand_hexkey = () => u8_to_hex(_rand_u8(8))
export const _rand_hexkey_batch = (length=5) => Array.from({length}, _rand_hexkey)
export const _hexkey_with_rand_body = width => (hk=_rand_hexkey()) => [hk, _rand_u8(width)]


export async function _as_body_testpair(body) ::
  if Number.isSafeInteger(body) ::
    body = _rand_u8(body)

  let was_iter = !Array.isArray(body) && body[Symbol.iterator] && body.next
  let body_buf = await bkc_arrbuf(body)
  if was_iter :: body = body_buf // iterator was consumed; used the result

  return @{} raw: body, buf: body_buf,
    expect_roundtrip: ans_body_buf =>
      expect(new Uint8Array(ans_body_buf))
      .to.be.deep.equal(new Uint8Array(body_buf))

export function _expect_aiter(tgt) ::
  expect(tgt[Symbol.asyncIterator]).to.be.a('function')
  expect(tgt.next).to.be.a('function')
  expect(tgt.throw).to.be.a('function')
  expect(tgt.return).to.be.a('function')
  return tgt

