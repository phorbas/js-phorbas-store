import {expect} from 'chai'

import {_rand_u8, _rand_hexkey, _as_body_testpair} from './check_utils.jsy'

export async function validate_bkc_random_key(_stg_, test_body) ::
  let test_key = _rand_hexkey()
  test_body = await _as_body_testpair(test_body)

  :: // random key should not exist
    let ans_exists = _stg_.bkc_exists(test_key)
    ans_exists = await ans_exists.then()
    if 0 !== ans_exists :: throw new Error('Expected bkc_exists of new key return 0')

  :: // body for random key should be undefined
    let ans = _stg_.bkc_fetch(test_key)
    ans = await ans.then()
    expect(ans).to.be.undefined


  :: // store test body at key
    let ans = _stg_.bkc_store(test_key, test_body.raw)
    ans = await ans.then()
    expect(ans).to.be.true

  :: // check key now exists
    let ans_exists = _stg_.bkc_exists(test_key)
    ans_exists = await ans_exists.then()
    if 1 !== ans_exists :: throw new Error('Expected bkc_exists to now be 1')

  :: // check round-trip of body content
    let ans_body = _stg_.bkc_fetch(test_key)
    ans_body = await ans_body.then()
    test_body.expect_roundtrip(ans_body)


export async function validate_bkc_overwrite(_stg_) ::
  throw new Error @ 'TODO'
  if 0 ::
        const rk_pairs = @[]
          @[] rand_u8_key(), rand_u8(1000)
          @[] rand_u8_key(), rand_u8(2000)
          @[] rand_u8_key(), rand_u8(4000)

        const rk_key_lst = rk_pairs.map(tpl => tpl[0])

        let immutable = _stg_.bkc_opt.immutable
        for const step of [0,1,2] ::
          let res = await _stg_.bkc_store(rk_pairs)
          if !step ::
            for let [k,r] of res ::
              mini_expect.ok @ undefined === r, 'Store should work on first iteration'

          else if !immutable ::
            for let [k,r] of res ::
              mini_expect.ok @ undefined === r, 'Store should work on mutable store subsequent iterations'

          else ::
            for let [k,r] of res ::
              mini_expect.ok @ false === r, 'Store should fail on immutable store subsequent iterations'


          let i=0
          for let [u8_key, u8_content] of await _stg_.bkc_fetch(rk_key_lst) ::
            const [rk_key, rk_content] = rk_pairs[i++]
            mini_expect.ok @ rk_key === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ undefined !== u8_content, 'We just stored it -- it should exist!'
            mini_expect.ok @ rk_content.byteLength === u8_content.byteLength, 'Byte length should match'

            const all_u8_match = u8_content.every @\ v,i => v === rk_content[i]
            mini_expect.ok @ all_u8_match, 'All u8 bytes should match'

