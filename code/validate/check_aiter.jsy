import {expect} from 'chai'

import {_expect_aiter, _rand_hexkey_batch, _hexkey_with_rand_body} from './check_utils.jsy'

export async function validate_bkc_stream_random_aiter(_stg_, opt={}) ::
  let test_key_list = _rand_hexkey_batch(opt.count ?? 5)
  let test_body_list = test_key_list.map(_hexkey_with_rand_body(opt.rand_width ?? 32))

  :: // random keys should not exist
    let ans_stream_exists = _stg_.bkc_stream_exists @
      opt.use_keys ? test_key_list : test_body_list

    _expect_aiter(ans_stream_exists)

    let count = 0
    for await let batch_result of ans_stream_exists ::
      for let [hk, ans] of batch_result ::
        expect(test_key_list.includes(hk)).to.be.true
        ans = await ans.then()
        expect(ans).to.equal(0)
        count++

    expect(count).to.equal(test_key_list.length)

  :: // body for random key should be undefined
    let ans_stream_fetch = _stg_.bkc_stream_fetch @
      opt.use_keys ? test_key_list : test_body_list

    _expect_aiter(ans_stream_fetch)

    let count = 0
    for await let batch_result of ans_stream_fetch ::
      for let [hk, ans] of batch_result ::
        expect(test_key_list.includes(hk)).to.be.true
        ans = await ans.then()
        expect(ans).to.be.undefined
        count++

    expect(count).to.equal(test_key_list.length)

  :: // store test body at key
    let ans_stream_store = _stg_.bkc_stream_store(test_body_list)

    _expect_aiter(ans_stream_store)

    let count = 0
    for await let batch_result of ans_stream_store ::
      for let [hk, ans] of batch_result ::
        expect(test_key_list.includes(hk)).to.be.true
        ans = await ans.then()
        expect(ans).to.be.true
        count++

    expect(count).to.equal(test_key_list.length)

  :: // check keys now exist
    let ans_stream_exists = _stg_.bkc_stream_exists @
      opt.use_keys ? test_key_list : test_body_list

    _expect_aiter(ans_stream_exists)

    let count = 0
    for await let batch_result of ans_stream_exists ::
      for let [hk, ans] of batch_result ::
        expect(test_key_list.includes(hk)).to.be.true
        ans = await ans.then()
        expect(ans).to.equal(1)
        count++

    expect(count).to.equal(test_key_list.length)


  :: // check round-trip of body content
    let ans_stream_fetch = _stg_.bkc_stream_fetch @
      opt.use_keys ? test_key_list : test_body_list

    _expect_aiter(ans_stream_fetch)

    let body_by_key = new Map(test_body_list)

    let count = 0
    for await let batch_result of ans_stream_fetch ::
      for let [hk, ans] of batch_result ::
        ans = await ans.then()
        expect(new Uint8Array(ans))
        .to.deep.equal(body_by_key.get(hk))
        count++

    expect(count).to.equal(test_key_list.length)

