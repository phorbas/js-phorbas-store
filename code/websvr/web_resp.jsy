import {u8_concat} from 'u8-utils'
import { as_u8_key, u8_to_hex, bkc_storage_verify} from '../_utils.jsy'

export { as_u8_key, u8_to_hex } from '../_utils.jsy'


export function web_responses_bkc(stg, opt={}) ::
  if null != stg ::
    bkc_storage_verify(stg)

  return @{}
    __proto__: _basic_responses(opt)
    stg

    async resp_has(request, stg=this.stg) ::
      try ::
        let hex_key = this.hk_for(request)
        let [[, exists]] =
          await stg.bkc_exists @#
            as_u8_key(hex_key)

        let {hdr} = this
        return new this.Response @ null,
          @{} status: exists ? 200 : 404
              headers: @{} ... hdr.common, ... hdr.has

      catch err ::
        return this._resp_500(err, 'has')


    async resp_get(request, stg=this.stg) ::
      try ::
        let hex_key = this.hk_for(request)
        let [[, u8_body]] =
          await stg.bkc_fetch @#
            as_u8_key(hex_key)

        let {hdr} = this
        return new this.Response @ u8_body,
          @{} status: u8_body ? 200 : 404
              headers: @{} 
                'Content-Type': 'application/octet-stream',
                ... hdr.common, ... hdr.get,
                'Content-Length': u8_body ? u8_body.byteLength : 0

      catch err ::
        return this._resp_500(err, 'get')


    async resp_set(request, stg=this.stg) ::
      try ::
        let hex_key = this.hk_for(request)
        let u8_body = await u8_body_for_stream(request)
        let [[, error]] =
          await stg.bkc_store @#
            [as_u8_key(hex_key), u8_body]

        let {hdr} = this
        return new this.Response @ null,
          @{} status: error ? 400 : 200
              headers: @{} ... hdr.common, ... hdr.set

      catch err ::
        return this._resp_500(err, 'set')


const _wm_hdlr_ = new WeakMap()
function _hdlr_ns_for(proto) ::
  let ns = _wm_hdlr_.get(proto)
  if undefined === ns ::
    _wm_hdlr_.set @ proto, ns = new Map()
  return ns

export function _basic_responses(opt={}) ::
  const {hdr} = opt, hk_for = opt.hk_for || iso_request_hk
  return @{}
    Response: opt.Response || globalThis.Response
    hdr, hk_for

    _resp_by_method: @{}
      HEAD: 'has'
      GET: 'get'
      PUT: 'set'
      POST: 'set'
      OPTIONS: 'options'

    as_handler: opt.as_handler || @ fn => fn
    method_for(method) ::
      let k = `resp_${this._resp_by_method[method] || method}`
      return (this[k] || this.resp_500).bind(this)

    handler_for(method, as_handler=this.as_handler) ::
      let ns =_hdlr_ns_for(this)
      let k = `hdl_${method}`
      let fn_hdl = ns.get(k)
      if undefined === fn_hdl ::
        fn_hdl = this.as_handler @
          this.method_for(method)
        ns.set @ this, fn_hdl
      return fn_hdl

    handle_by_method(request, ... args) ::
      let fn_hdl = this.handler_for(request.method)
      return fn_hdl(request, ...args)

    async resp_options(request) ::
      let {hdr} = this
      return new this.Response @ null,
        @{} status: 200
            headers: @{} ... hdr.common, ... hdr.options

    resp_500(err, stg_op) ::
      return this._resp_500(err, stg_op)

    on_error: opt.on_error
    _resp_500(err, stg_op) ::
      if this.on_error ::
        this.on_error(err, stg_op)
      return new this.Response('', {status: 500})


const _rx_hk = /\/([0-9A-Fa-f]+)$/
export function iso_request_hk({url, headers: h}) ::
  let hk = 'function' === typeof h.get
    ? h.get('x-hk') : h['x-hk']

  if ! hk ::
    let m = _rx_hk.exec(`${url}`)
    hk = m && m[1]
  return hk


export async function u8_body_for_stream(aiter_src) ::
  if ! aiter_src[Symbol.asyncIterator] ::
    // adapter for ReadableStream while asyncIterator is finalized
    aiter_src = aiter_reader @ aiter_src.getReader()

  let parts = []
  for await let chunk of aiter_src ::
    parts.push(chunk)
  return u8_concat(parts)


async function * aiter_reader(reader) ::
  try ::
    while 1 ::
      let { done, value } = await reader.read()
      if done :: return
      yield value
  finally ::
    reader.releaseLock()

