import { _bkc_storage_, bkc_arrbuf } from '../bkc_abstract.jsy'

export {bkc_arrbuf}

export function bkc_fetch_request(url_base, opt={}) ::
  const Request = opt.Request || Request
  return _bkc_fetch @ opt.fetch || fetch, opt,
    hexkey => new Request(new URL(hexkey, url_base), opt.req_init)

export default  bkc_fetch
export function bkc_fetch(url_base, opt={}) ::
  return _bkc_fetch @ opt.fetch || fetch, opt,
    hexkey => new URL(hexkey, url_base)

export async function _bkc_fetch(fetch, opt, as_req) ::
  const fetch_opts = opt.fetch_opts
  const immutable = !! opt.immutable

  return _bkc_storage_.with @:
    bkc_opt: @{} immutable

    bkc_exists
    async bkc_fetch(hexkey) ::
      let resp = await fetch @ as_req(hexkey),
        @{} ... fetch_opts
            method: 'GET', headers: {'x-hk': hexkey}, 

      if resp.ok ::
        return resp.arrayBuffer()

    async bkc_store(hexkey, body) ::
      if immutable && await bkc_exists(hexkey) ::
        return false

      body = await bkc_arrbuf(body)
      let resp = await fetch @ as_req(hexkey),
        @{} ... fetch_opts
            method: 'POST', headers: {'x-hk': hexkey}
            body

      if ! resp.ok ::
        let {url, status, statusText} = resp
        let err = new Error(`${statusText || status}`)
        err.url = resp.url
        err.status = status
        return err

      return null

  async function bkc_exists(hexkey) ::
    let resp = await fetch @ as_req(hexkey),
      @{} ... fetch_opts
          method: 'HEAD', headers: {'x-hk': hexkey}

    return resp.ok ? 1 : 0

