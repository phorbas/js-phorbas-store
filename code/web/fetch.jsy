import { bkc_arrbuf } from '../core.jsy'
import { _bkc_storage_ } from '../abstract/bkc_abstract_single.jsy'

export * from '../core.jsy'

export {bkc_fetch as default, bkc_fetch as bkc_fetch_request}
export async function bkc_fetch(url_base, opt={}) ::
  const as_req = opt.as_request ?? _bind_hexkey_request(opt)
  const fetch = opt.fetch ?? globalThis.fetch
  const fetch_opts = opt.fetch_opts
  const immutable = !! opt.immutable

  async function bkc_exists(hexkey, kw) ::
    let resp = await fetch @
      as_req(url_base, hexkey, kw?.signal),
      @{} ... fetch_opts
          method: 'HEAD'
          headers: @{} 'x-hk': hexkey
          signal: kw?.signal

    return resp.ok ? 1 : 0

  return _bkc_storage_.with @:
    bkc_opt: @{} immutable

    bkc_exists

    async bkc_fetch(hexkey, kw) ::
      let resp = await fetch @
        as_req(url_base, hexkey, kw?.signal),
        @{} ... fetch_opts
            method: 'GET'
            headers: @{} 'x-hk': hexkey
            signal: kw?.signal

      if resp.ok ::
        return await resp.arrayBuffer()

    async bkc_store(hexkey, body, kw) ::
      if immutable && await bkc_exists(hexkey, kw) ::
        return false

      body = await bkc_arrbuf(body)

      let resp = await fetch @
        as_req(url_base, hexkey, kw?.signal),
        @{} ... fetch_opts
            method: 'POST'
            headers: @{}
              'Content-Type': 'application/octet-stream',
              'x-hk': hexkey
            signal: kw?.signal
            body

      if ! resp.ok ::
        let {url, status, statusText} = resp
        let err = new Error(`${statusText || status}`)
        err.url = resp.url
        err.status = status
        return err

      return null


export function _bind_hexkey_request(opt) ::
  const Request = opt.Request ?? globalThis.Request
  return (url_base, hexkey, signal) => new Request @
      new URL(hexkey, url_base)
      @{} signal, ... opt.request_init

