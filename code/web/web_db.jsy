import { _bkc_stream_storage_, bkc_batch_stream } from '../bkc_abstract.jsy'
import { _bkc_fetch_ans } from '../bkc_abstract.jsy'
import { bkc_arrbuf, bkc_pair_arrbuf } from '../bkc_abstract.jsy'

export { bkc_arrbuf , bkc_pair_arrbuf }

export default bkc_web_db
export async function bkc_web_db(opt={}) ::
  if 'string' === typeof opt ::
    let [db, store] = opt.split('/')
    opt = {db, store}

  const store_name = opt.store || 'kv'
  const db_name = opt.db || 'phorbas'

  if opt.wipe ::
    await _idb_req @
      indexedDB.deleteDatabase(db_name)

  const req_open = indexedDB.open(db_name, 1)
  req_open.onupgradeneeded = evt =>
    evt.target.result.createObjectStore(store_name)

  const idb = await _idb_req(req_open)

  return Object.create @ _bkc_indexdb_proto_, @{}
    _txn_ro: @{} value: ()=> _idb_txn(idb, store_name, 'readonly')
    _txn_rw: @{} value: ()=> _idb_txn(idb, store_name, 'readwrite')



const _bkc_indexdb_proto_ = _bkc_stream_storage_.with @:
  bkc_opt: @{}

  async * bkc_stream_exists(hexkey_aiter, kw) ::
    let _bkc_pair = this._bkc_pair()
    for await let batch of bkc_batch_stream(hexkey_aiter, _bkc_pair, kw) ::
      let [kvdb, txn_done] = this._txn_ro()
      for let pair of batch ::
        pair[1] = kvdb.count(pair[0])

      await txn_done

      for const pair of batch ::
        pair[1] = pair[1].result ? 1 : 0

      yield batch

  async * bkc_stream_fetch(hexkey_aiter, kw) ::
    let _bkc_pair = this._bkc_pair()
    for await let batch of bkc_batch_stream(hexkey_aiter, _bkc_pair, kw) ::
      let [kvdb, txn_done] = this._txn_ro()
      for let pair of batch ::
        pair[1] = kvdb.get(pair[0])

      await txn_done

      for const pair of batch ::
        pair[1] = _bkc_fetch_ans(pair[1].result, false, kw?.xform)

      yield batch

  async * bkc_stream_store(hexkey_body_aiter, kw) ::
    let _bkc_body_pair = this._bkc_pair(bkc_pair_arrbuf)

    for await let batch of bkc_batch_stream(hexkey_body_aiter, _bkc_body_pair, kw) ::
      for let pair of batch ::
        pair[1] = await pair[1]

      let [kvdb, txn_done] = this._txn_rw()
      for let pair of batch ::
        pair[1] = kvdb.put(pair[1], pair[0])

      await txn_done

      for const pair of batch ::
        pair[1] = pair[1].error ?? null

      yield batch


function _idb_txn(idb, store_name, mode) ::
  const txn = idb.transaction(store_name, mode)
  return @[]
    txn.objectStore(store_name),
    new Promise @\ resolve, reject ::
      txn.oncomplete = resolve
      txn.onabort = txn.onerror = @=> reject @ txn.error

function _idb_req(req) ::
  return new Promise @\ resolve, reject ::
    req.onsuccess = @=> resolve @ req.result
    req.onerror = @=> reject @ req.error

