import { _bkc_storage_, bkc_arrbuf } from '../bkc_abstract.jsy'

export {bkc_arrbuf}

export default bkc_web_cache_fetch
export async function bkc_web_cache_fetch(cache_store, url_base, opt={}) ::
  const immutable = !! opt.immutable
  const prefix = opt.prefix ?? ''
  const _opt_match = opt.match ?? {ignoreMethod: true}
  const _as_req = hexkey =>
    new Request(new URL(prefix+hexkey, url_base), opt.request)

  cache_store = await cache_store
  return _bkc_storage_.with @:
    bkc_opt: @{} immutable

    async bkc_exists(hexkey) ::
      let req = _as_req(hexkey)
      let resp = await cache_store.match(req, _opt_match)

      if undefined === resp ::
        try :: // attempt fetching it
          await cache_store.add(req)
        catch err ::
          return 0

      return 1

    async bkc_fetch(hexkey) ::
      let req = _as_req(hexkey)
      let resp = await cache_store.match(req, _opt_match)

      if undefined === resp ::
        try :: // attempt fetching it
          await cache_store.add(req)
        catch err :: return

        resp = await cache_store.match(req)

      return resp.arrayBuffer()

    async bkc_store(hexkey, body) ::
      let req = _as_req(hexkey), resp
      if immutable ::
        resp = await cache_store.match(req, _opt_match)
        try ::
          resp ??= await cache_store.add(req)
          return false // return false for immutable existing entry
        catch err :: // pass

      body = await bkc_arrbuf(body)
      resp = await fetch @ req.url,
        @{} method: 'POST'
            headers: { 'x-hk': hexkey }
            body

      if ! resp.ok ::
        let {url, status, statusText} = resp
        let err = new Error(`${statusText || status}`)
        err.url = resp.url
        err.status = status
        return err

      resp = new Response @
        body = await bkc_arrbuf(body),
        @{} status: 200, headers: @{} 'Content-Length': body.byteLength

      await cache_store.put(req, resp)
      return null
