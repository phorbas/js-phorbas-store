import {as_arrbuf} from '@phorbas/opaque/esm/subtle/utils.js'


export const _bkc_storage_mixin_ = @{}
  //bkc_opt: {}
  //async bkc_store(hexkey, body) ::
  //async bkc_exists(hexkey) ::
  //async bkc_fetch(hexkey) ::

  async bkc_fetch_as(hexkey, as_xform) ::
    return this.bkc_fetch(hexkey).then(as_xform)

  // async * bkc_stream_exists(hexkey_iter) ::
  // async * bkc_stream_fetch(hexkey_iter, xform) ::
  // async * bkc_stream_store(hexkey_body_iter) ::

  _bkc_pair_api_: @{}
    then(y,n) :: return Promise.resolve(this[1]).then(ans => [this[0], ans]).then(y,n)

  _bkc_pair(fn_pair_op) ::
    return hk_pair => Object.assign @
      [hk_pair[0], fn_pair_op?.call(this, hk_pair)]
      this._bkc_pair_api_

  with(...args) ::
    return Object.assign({__proto__: this}, ...args)



export const _bkc_storage_ = @{}
  ... _bkc_storage_mixin_

  async * bkc_stream_exists(hexkey_iter) ::
    let _bkc_exists = this._bkc_pair @
      ([hexkey]) => this.bkc_exists(hexkey)

    return yield * bkc_batch_stream(hexkey_iter, _bkc_exists)

  async * bkc_stream_fetch(hexkey_iter, as_xform) ::
    let _bkc_fetch = this._bkc_pair @
      ([hexkey]) => this.bkc_fetch(hexkey).then(as_xform)

    return yield * bkc_batch_stream(hexkey_iter, _bkc_fetch)

  async * bkc_stream_store(hexkey_body_iter) ::
    let _bkc_store = this._bkc_pair @
      ([hexkey, body]) => this.bkc_store(hexkey, body)

    return yield * bkc_batch_stream(hexkey_body_iter, _bkc_store)


export const _bkc_stream_storage_ = @{}
  ... _bkc_storage_mixin_

  async bkc_exists(hexkey) ::
    for await let [pair] of this.bkc_stream_exists([[hexkey]]) ::
      return pair[1]
    return 0

  async bkc_fetch(hexkey) ::
    for await let [pair] of this.bkc_stream_fetch([[hexkey]]) ::
      return pair[1]

  async bkc_store(hexkey, body) ::
    for await let [pair] of this.bkc_stream_store([[hexkey, body]]) ::
      return pair[1]



export const bkc_arrbuf = body => as_arrbuf(body)
export const bkc_pair_arrbuf = ([hexkey, body]) => bkc_arrbuf(body)


const _as_tuples = v => v.trim ? [v] : v
export async function * bkc_batch_stream(aiter_batches, bkc_fn) ::
  if 'string' === typeof aiter_batches :: throw new Error()
  if Array.isArray(aiter_batches) :: aiter_batches = [aiter_batches]

  for await let batch of aiter_batches ::
    if batch?.length ::
      if batch.trim :: batch = [[batch]]
      else batch = batch.map(_as_tuples)
      yield bkc_fn ? batch.map(bkc_fn) : batch



// bkc api verification -- binary key (binary) content
export async function bkc_storage_verify(stg) ::
  stg = await stg
  _is_fn(stg, 'bkc_exists')
  _is_fn(stg, 'bkc_fetch')
  _is_fn(stg, 'bkc_store')

  _is_fn(stg, 'bkc_stream_exists')
  _is_fn(stg, 'bkc_stream_fetch')
  _is_fn(stg, 'bkc_stream_store')

  if 'object' !== typeof stg.bkc_opt ::
    throw new TypeError('Expected object "bkc_opt" not present')

  return stg

export function _is_fn(o, k) ::
  if 'function' !== typeof o[k] ::
    throw new TypeError(`Expected function "${k}" not present`)

