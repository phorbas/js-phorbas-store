import {as_arrbuf, _as_arrbuf} from '@phorbas/opaque/esm/subtle/utils.js'
export {as_arrbuf, _as_arrbuf}


export const _bkc_storage_mixin_ = @{}
  //bkc_opt: {}
  //async bkc_store(hexkey, body, {signal}) ::
  //async bkc_exists(hexkey, {signal}) ::
  //async bkc_fetch(hexkey, {signal}) ::

  // async * bkc_stream_store(hexkey_body_aiter, {signal}) ::
  // async * bkc_stream_exists(hexkey_aiter, {signal}) ::
  // async * bkc_stream_fetch(hexkey_aiter, {signal, xform}) ::

  _bkc_record(fn_record_op) ::
    return rec => ::
      (rec = [... rec]).then = _rec_then
      if fn_record_op :: rec[1] = fn_record_op(rec)
      return rec

  with(...args) ::
    return Object.assign({__proto__: this}, ...args)

function _rec_then(y,n) ::
  let rec = [... this]
  return Promise.resolve(rec[1])
    .then(ans => (rec[1]=ans, rec))
    .then(y,n)



export const _bkc_storage_ = @{}
  ... _bkc_storage_mixin_

  async * bkc_stream_store(hexkey_body_aiter, kw) ::
    let _bkc_store = this._bkc_record @
      ([hexkey, body]) => this.bkc_store(hexkey, body, kw)

    return yield * bkc_batch_stream(hexkey_body_aiter, _bkc_store, kw)

  async * bkc_stream_exists(hexkey_aiter, kw) ::
    let _bkc_exists = this._bkc_record @
      ([hexkey]) => this.bkc_exists(hexkey, kw)

    return yield * bkc_batch_stream(hexkey_aiter, _bkc_exists, kw)

  async * bkc_stream_fetch(hexkey_aiter, kw) ::
    let _bkc_fetch = this._bkc_record @
      ([hexkey]) => this.bkc_fetch(hexkey, kw).then(kw?.xform)

    return yield * bkc_batch_stream(hexkey_aiter, _bkc_fetch, kw)



export const _bkc_stream_storage_ = @{}
  ... _bkc_storage_mixin_

  async bkc_exists(hexkey, kw) ::
    for await let [rec] of this.bkc_stream_exists([[hexkey]], kw) ::
      return rec[1]
    return 0

  async bkc_fetch(hexkey, kw) ::
    for await let [rec] of this.bkc_stream_fetch([[hexkey]], kw) ::
      return rec[1]

  async bkc_store(hexkey, body, kw) ::
    for await let [rec] of this.bkc_stream_store([[hexkey, body]], kw) ::
      return rec[1]



export const _bkc_ident = v => v
export const bkc_arrbuf = body => as_arrbuf(body)
export const bkc_rec_arrbuf = ([key, body]) => bkc_arrbuf(body)

export function _bkc_fetch_ans(buf, as_copy, xform) ::
  buf = _as_arrbuf(buf, as_copy)

  return xform ? Promise.resolve(buf).then(xform) : buf


const _as_tuples = v => v.trim ? [v] : [...v]
export async function * bkc_batch_stream(aiter_batches, bkc_fn, kw) ::
  if 'string' === typeof aiter_batches :: throw new Error()
  if Array.isArray(aiter_batches) :: aiter_batches = [aiter_batches]

  for await let batch of aiter_batches ::
    if kw?.signal?.aborted :: return

    if batch?.length ::
      if batch.trim :: batch = [[batch]]
      else batch = batch.map(_as_tuples)
      yield bkc_fn ? batch.map(bkc_fn) : batch



// bkc api verification -- binary key (binary) content
export async function bkc_storage_verify(stg, allow_null) ::
  stg = await stg
  if null == stg ::
    if allow_null :: return stg
    throw new TypeError('Expected a non-null storage instance')

  _is_fn(stg, 'bkc_exists')
  _is_fn(stg, 'bkc_fetch')
  _is_fn(stg, 'bkc_store')

  _is_fn(stg, 'bkc_stream_exists', 2)
  _is_fn(stg, 'bkc_stream_fetch', 2)
  _is_fn(stg, 'bkc_stream_store', 2)

  if 'object' !== typeof stg.bkc_opt ::
    throw new TypeError('Expected object "bkc_opt" not present')

  return stg

function _is_fn(o, k, n_args) ::
  let fn = o[k]
  if 'function' !== typeof fn :: throw new TypeError(`Expected function "${k}" not present`)
  if n_args && fn.length !== n_args :: throw new TypeError(`Expected function "${k}" to have ${n_args} args, found ${fn.length}: ${fn}`)

