import {describe, it, before, after} from '#test_bdd'

import {bkc_storage_verify} from './bkc_abstract.jsy'
import * as check_single from './validate/check_single.jsy'
import * as check_aiter from './validate/check_aiter.jsy'
import * as check_async_gen from './validate/check_async_gen.jsy'

export * from './_utils.jsy'
export {bkc_storage_verify} from './bkc_abstract.jsy'
export * from './validate/check_utils.jsy'
export * from './validate/check_single.jsy'
export * from './validate/check_aiter.jsy'
export * from './validate/check_async_gen.jsy'


export const validate_backend = Object.assign @
  _validate_backend.bind(null, describe)
  @{} only: _validate_backend.bind(null, describe.only)
      skip: _validate_backend.bind(null, describe.skip)


function _validate_backend(_describe_fn, backend_name, opt) ::
  if 'function' === typeof opt :: opt = {bkc_create: opt}

  _describe_fn @ `backend: ${backend_name}`, function () ::
    if undefined !== opt.slow :: opt.slow(this)

    let _stg_, _ctx_
    before @::>
      _stg_ = await opt.bkc_create(_ctx_={})
      if null == _stg_ ::
        throw new TypeError("create bkc_storage did not return an instance")

    after @::>
      await opt.bkc_cleanup?.(_stg_, _ctx_)
      _ctx_ = null


    it @ 'bkc storage verify', () => bkc_storage_verify(_stg_)


    describe @ 'bkc api', @::
      it @ 'with string', () => check_single.validate_bkc_random_key(_stg_, 'some test string')
      it @ 'with array', () => check_single.validate_bkc_random_key(_stg_, ['some', ' ~ ', 'test', ' ~ ', 'string', 'array'])
      it @ 'with iterable', () => check_single.validate_bkc_random_key(_stg_, Iterator.from(['some', ' ~ ', 'test', ' ~ ', 'iterator']))
      it @ 'with Blob', () => check_single.validate_bkc_random_key(_stg_, new Blob(['some', ' ~ ', 'test', ' ~ ', 'blob']))
      it @ 'with Blob with type', () => check_single.validate_bkc_random_key(_stg_, new Blob(['some', ' ~ ', 'plaintext', ' ~ ', 'blob'], {type: 'text/plain'}))

      it @ 'with random 16 byte binary', () => check_single.validate_bkc_random_key(_stg_, 16)
      it @ 'with random 1024 byte binary', () => check_single.validate_bkc_random_key(_stg_, 1024)
      it @ 'with random 16384 byte binary', () => check_single.validate_bkc_random_key(_stg_, 16384)

      it @ 'random key aiter', () => check_aiter.validate_bkc_stream_random_aiter(_stg_)
      it @ 'random key async generator', () => check_async_gen.validate_bkc_stream_random_async_gen(_stg_)


    let custom_tests = opt.tests
    if custom_tests ::
      if ! custom_tests[Symbol.iterator] ::
        custom_tests = Object.entries(custom_tests)

      describe @ 'custom', @::
        for let [test_name, test_fn] of custom_tests ::
          it @ test_name, () => test_fn(_stg_, _ctx_)



/*
function _validate_backend(opt) ::
    if 'function' === typeof opt ::
      opt = {create: opt}

    let _stg_, _ctx_
    before @::>
      _stg_ = await opt.create(_ctx_={})
      if null == _stg_ ::
        throw new TypeError("create_bkc_storage did not return an instance")

    if opt.done ::
      after @::>
        await opt.done(_ctx_)
        _stg_ = _ctx_ = undefined

    opt.skip_api || describe @ 'api', function() ::
      if (undefined !== opt.slow) opt.slow(this)

      it @ 'bkc_exists', @::>
        mini_expect.func @ _stg_.bkc_exists

        const rk_key_lst = @[] rand_u8_key(), rand_u8_key(), rand_u8_key()

        const p = mini_expect.promise @
          _stg_.bkc_exists(rk_key_lst)

        const ans = mini_expect.array @ await p

        let i=0
        for let [u8_key, exists] of ans ::
          mini_expect.ok @ rk_key_lst[i++] === u8_key, 'aligned result array of identical u8_key'
          mini_expect.ok @ 0 === exists, '256-bit crypto random keys should not be present in the storage backend'


      it @ 'bkc_fetch', @::>
        mini_expect.func @ _stg_.bkc_fetch

        const rk_key_lst = @[] rand_u8_key(), rand_u8_key(), rand_u8_key()

        const p = mini_expect.promise @
          _stg_.bkc_fetch(rk_key_lst)

        const ans = mini_expect.array @ await p

        let i=0
        for let [u8_key, u8_content] of ans ::
          mini_expect.ok @ rk_key_lst[i++] === u8_key, 'aligned result array of identical u8_key'
          mini_expect.ok @ undefined === u8_content, '256-bit crypto random keys should not be present in the storage backend'


      it @ 'bkc_store', @::>
        mini_expect.func @ _stg_.bkc_store

        const rk_pairs = @[]
          @[] rand_u8_key(), utf8_to_u8('first')
          @[] rand_u8_key(), utf8_to_u8('second')
          @[] rand_u8_key(), utf8_to_u8('third')

        const p = mini_expect.promise @
          _stg_.bkc_store(rk_pairs)

        const ans = mini_expect.array @ await p
        let i=0
        for let [u8_key, err] of ans ::
          mini_expect.ok @ rk_pairs[i++][0] === u8_key, 'aligned result array of identical u8_key'
          mini_expect.ok @ undefined === err, 'unexpected errors during write'


    opt.skip_one || describe @ 'one', function() ::
      if (undefined !== opt.slow) opt.slow(this)

      it @ 'round-trip one', @::>
        let rk_src_key = rand_u8_key()
        let rk_src_content = rand_u8(1024)

        :: // should not (yet) exist
          let [[u8_key, exists]] = await _stg_.bkc_exists([rk_src_key])
          mini_expect.ok @ rk_src_key === u8_key, 'aligned result array of identical u8_key'
          mini_expect.ok @ 0 === exists, '256-bit crypto random keys should not be present in the storage backend'

        :: // should not (yet) have content
          let [[u8_key, u8_content]] = await _stg_.bkc_fetch([rk_src_key])
          mini_expect.ok @ rk_src_key === u8_key, 'aligned result array of identical u8_key'
          mini_expect.ok @ undefined === u8_content, '256-bit crypto random keys should not be present in the storage backend'


        :: // store the pairs
          let [[u8_key, err]] = await _stg_.bkc_store([[rk_src_key, rk_src_content]])
          mini_expect.ok @ rk_src_key === u8_key, 'aligned result array of identical u8_key'
          mini_expect.ok @ undefined === err, 'unexpected errors during write'

        :: // should now exist
          let [[u8_key, exists]] = await _stg_.bkc_exists([rk_src_key])
            mini_expect.ok @ rk_src_key === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ 1 === exists, 'We just stored it -- it should exist!'

        :: // should now have content
          let [[u8_key, u8_content]] = await _stg_.bkc_fetch([rk_src_key])
          mini_expect.ok @ rk_src_key === u8_key, 'aligned result array of identical u8_key'
          mini_expect.ok @ undefined !== u8_content, 'We just stored it -- it should exist!'
          mini_expect.ok @ rk_src_content.byteLength === u8_content.byteLength, 'Byte length should match'

          const all_u8_match = u8_content.every @\ v,i => v === rk_src_content[i]
          mini_expect.ok @ all_u8_match, 'All u8 bytes should match'


    opt.skip_sequences || describe @ 'sequences', function() ::
      if (undefined !== opt.slow) opt.slow(this)

      it @ 'round-trip 3 random u8 pairs', @::>

        const rk_pairs = @[]
          @[] rand_u8_key(), rand_u8 @ 1024
          @[] rand_u8_key(), rand_u8 @ 16*1024
          @[] rand_u8_key(), rand_u8 @ opt.max_item_size || 1024*1024

        const rk_key_lst = rk_pairs.map(tpl => tpl[0])

        :: // should not (yet) exist
          let i=0
          for let [u8_key, exists] of await _stg_.bkc_exists(rk_key_lst) ::
            mini_expect.ok @ rk_key_lst[i++] === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ 0 === exists, '256-bit crypto random keys should not be present in the storage backend'


        :: // should not (yet) have content
          let i=0
          for let [u8_key, u8_content] of await _stg_.bkc_fetch(rk_key_lst) ::
            mini_expect.ok @ rk_key_lst[i++] === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ undefined === u8_content, '256-bit crypto random keys should not be present in the storage backend'


        :: // store the pairs
          let i=0
          for let [u8_key, err] of await _stg_.bkc_store(rk_pairs) ::
            mini_expect.ok @ rk_pairs[i++][0] === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ undefined === err, 'unexpected errors during write'


        :: // should now exist
          let i=0
          for let [u8_key, exists] of await _stg_.bkc_exists(rk_key_lst) ::
            mini_expect.ok @ rk_key_lst[i++] === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ 1 === exists, 'We just stored it -- it should exist!'

        :: // should now have content
          let i=0
          for let [u8_key, u8_content] of await _stg_.bkc_fetch(rk_key_lst) ::
            const [rk_key, rk_content] = rk_pairs[i++]
            mini_expect.ok @ rk_key === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ undefined !== u8_content, 'We just stored it -- it should exist!'
            mini_expect.ok @ rk_content.byteLength === u8_content.byteLength, 'Byte length should match'

            const all_u8_match = u8_content.every @\ v,i => v === rk_content[i]
            mini_expect.ok @ all_u8_match, 'All u8 bytes should match'


      it @ 'overwrite test', @::>
        const rk_pairs = @[]
          @[] rand_u8_key(), rand_u8(1000)
          @[] rand_u8_key(), rand_u8(2000)
          @[] rand_u8_key(), rand_u8(4000)

        const rk_key_lst = rk_pairs.map(tpl => tpl[0])

        let immutable = _stg_.bkc_opt.immutable
        for const step of [0,1,2] ::
          let res = await _stg_.bkc_store(rk_pairs)
          if !step ::
            for let [k,r] of res ::
              mini_expect.ok @ undefined === r, 'Store should work on first iteration'

          else if !immutable ::
            for let [k,r] of res ::
              mini_expect.ok @ undefined === r, 'Store should work on mutable store subsequent iterations'

          else ::
            for let [k,r] of res ::
              mini_expect.ok @ false === r, 'Store should fail on immutable store subsequent iterations'


          let i=0
          for let [u8_key, u8_content] of await _stg_.bkc_fetch(rk_key_lst) ::
            const [rk_key, rk_content] = rk_pairs[i++]
            mini_expect.ok @ rk_key === u8_key, 'aligned result array of identical u8_key'
            mini_expect.ok @ undefined !== u8_content, 'We just stored it -- it should exist!'
            mini_expect.ok @ rk_content.byteLength === u8_content.byteLength, 'Byte length should match'

            const all_u8_match = u8_content.every @\ v,i => v === rk_content[i]
            mini_expect.ok @ all_u8_match, 'All u8 bytes should match'


    if opt.test_immutable ::
      describe @ 'immutable', function () ::
        // TODO: future immutable tests in addition to 'overwrite test' above


export const validate_immutable = _as_test_suite(_validate_immutable)

function _validate_immutable(opt) ::
    if 'function' === typeof opt ::
      opt = {create: opt}
    opt.test_immutable = true
    return _validate_backend(opt)


export const mini_expect = @{}
  ok(ok, msg) ::
    if ! ok :: throw new Error(msg)

  func: val =>
    mini_expect.__check @ val, 'function', 'function' === typeof val

  string: val =>
    mini_expect.__check @ val, 'string', 'string' === typeof val

  promise: val =>
    mini_expect.__check @ val, 'Promise', null != val && 'function' === typeof val.then

  array: val =>
    mini_expect.__check @ val, 'array', Array.isArray(val)

  __check(val, msg, ok) ::
    if ! ok ::
      throw new TypeError(`Expected ${msg}`)
    return val
*/

