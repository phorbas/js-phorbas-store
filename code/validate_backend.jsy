import {bkc_storage_verify} from './bkc_abstract.jsy'
import * as check_single from './validate/check_single.jsy'
import * as check_aiter from './validate/check_aiter.jsy'
import * as check_async_gen from './validate/check_async_gen.jsy'

export * from './_utils.jsy'
export {bkc_storage_verify} from './bkc_abstract.jsy'
export * from './validate/check_utils.jsy'
export * from './validate/check_single.jsy'
export * from './validate/check_aiter.jsy'
export * from './validate/check_async_gen.jsy'


export function validate_backend(test_bdd, backend_name, opt) ::
  const {describe, it, after, before} = test_bdd
  if 'function' !== typeof describe ::
    throw new Error('validate_backend expects #test_bdd module as first argument')

  if 'function' === typeof opt :: opt = {bkc_create: opt}

  describe @ `backend: ${backend_name}`, function () ::
    if undefined !== opt.slow :: opt.slow(this)

    let _stg_, _ctx_
    before @::>
      _stg_ = opt.bkc_create(_ctx_={})
      _stg_ = _stg_ ? await _stg_.then() : _stg_ // ensure it is really an async promise
      if null == _stg_ ::
        throw new TypeError("create bkc_storage did not return an instance")

    after @::>
      await opt.bkc_cleanup?.(_stg_, _ctx_)
      _ctx_ = null


    it @ 'bkc storage verify', () => bkc_storage_verify(_stg_)

    if opt.simple ::
      it @ 'with string', () => check_single.validate_bkc_random_key(_stg_, 'some simple test string')
      it @ 'overwrite test', () => check_single.validate_bkc_overwrite(_stg_)
      return

    if opt.simple_stream ::
      it @ 'stream with async iteration', () => check_aiter.validate_bkc_stream(_stg_)
      return

    describe @ 'bkc api', @::
      it @ 'with string', () => check_single.validate_bkc_random_key(_stg_, 'some test string')
      it @ 'with array', () => check_single.validate_bkc_random_key(_stg_, ['some', ' ~ ', 'test', ' ~ ', 'string', 'array'])
      it @ 'with iterable', () => check_single.validate_bkc_random_key(_stg_, Iterator.from(['some', ' ~ ', 'test', ' ~ ', 'iterator']))
      it @ 'with Blob', () => check_single.validate_bkc_random_key(_stg_, new Blob(['some', ' ~ ', 'test', ' ~ ', 'blob']))
      it @ 'with Blob with type', () => check_single.validate_bkc_random_key(_stg_, new Blob(['some', ' ~ ', 'plaintext', ' ~ ', 'blob'], {type: 'text/plain'}))

      it @ 'with random 16 byte binary', () => check_single.validate_bkc_random_key(_stg_, 16)
      it @ 'with random 1024 byte binary', () => check_single.validate_bkc_random_key(_stg_, 1024)
      it @ 'with random 16384 byte binary', () => check_single.validate_bkc_random_key(_stg_, 16384)

      it @ 'overwrite test', () => check_single.validate_bkc_overwrite(_stg_)

      if ! opt.skip_batch_count ::
        it @ 'stream with async generator', () => check_async_gen.validate_bkc_stream_async_gen(_stg_)

      it @ 'stream with async iteration', () => check_aiter.validate_bkc_stream(_stg_)
      it @ 'stream with async batch', () => check_aiter.validate_bkc_stream_batch(_stg_)
      it @ 'stream with async fetch with xform', () => check_aiter.validate_bkc_stream_batch_xform(_stg_)
      it @ 'stream with abort signal', () => check_aiter.validate_bkc_stream_batch_abort(_stg_)


    let custom_tests = opt.tests
    if custom_tests ::
      if ! custom_tests[Symbol.iterator] ::
        custom_tests = Object.entries(custom_tests)

      describe @ 'custom', @::
        for let [test_name, test_fn] of custom_tests ::
          it @ test_name, () => test_fn(_stg_, _ctx_)

