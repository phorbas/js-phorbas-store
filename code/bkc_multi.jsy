import { _bkc_storage_, bkc_arrbuf, _bkc_ident } from './bkc_abstract.jsy'
import { bkc_storage_verify, bkc_batch_stream } from './bkc_abstract.jsy'

export { bkc_arrbuf, bkc_storage_verify, bkc_batch_stream }

export default bkc_multi
export async function bkc_multi(opt) ::
  if 'function' === typeof opt :: opt = {bkc_lookup: opt}

  return _bkc_multi_mixin_.with @:
    bkc_opt: @{} proxy: true

    _xf_encode_body: opt.encode_body ?? _bkc_ident
    _xf_decode_body: opt.decode_body ?? _bkc_ident

    async _bkc_lookup(key, body) ::
      let stg_tgt = await opt.bkc_lookup(key, body)
      return Array.isArray(stg_tgt) ? stg_tgt
        : [stg_tgt, key, body]


export const _bkc_multi_mixin_ = @{}
  ... _bkc_storage_

  async bkc_store(key, body, kw) ::
    body = this._xf_encode_body(bkc_arrbuf(body))
    let [stg_tgt, stg_key, stg_body] = await this._bkc_lookup(key, body)
    return (await stg_tgt).bkc_store(stg_key, stg_body, kw)

  async bkc_exists(key, kw) ::
    let [stg_tgt, stg_key] = await this._bkc_lookup(key)
    return (await stg_tgt).bkc_exists(stg_key, kw)

  async bkc_fetch(key, kw) ::
    let [stg_tgt, stg_key] = await this._bkc_lookup(key)

    let body = (await stg_tgt).bkc_fetch(stg_key, kw)
    return this._xf_decode_body(body)

