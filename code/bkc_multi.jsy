import { _bkc_storage_, bkc_arrbuf, _bkc_ident } from './bkc_abstract.jsy'
import { bkc_storage_verify, bkc_batch_stream } from './bkc_abstract.jsy'

export { bkc_arrbuf, bkc_storage_verify, bkc_batch_stream }

let _bkc_multi_lite
export function bkc_multi(opt={}) ::
  if 'function' === typeof opt :: opt = {bkc_lookup: opt}
  _bkc_multi_lite ??= _bkc_storage_.with(_bkc_multi_mixin_)
  return _bkc_multi_with(_bkc_multi_lite, opt)

export default bkc_multi

export async function _bkc_multi_with(_bkc_multi_, opt, _mixin_tail_) ::
  if 'function' === typeof opt :: opt = {bkc_lookup: opt}

  return _bkc_multi_.with @:
    bkc_opt: @{} proxy: true

    _xf_encode_body: opt.encode_body ?? _bkc_ident
    _xf_decode_body: opt.decode_body ?? _bkc_ident
    _xf_lookup: bkc_multi_lookup(opt.bkc_lookup)

    ... _mixin_tail_

export const bkc_multi_lookup = bkc_lookup_fn =>
  async pair => (pair.stg = await bkc_lookup_fn(pair), pair)

export const _bkc_multi_mixin_ = @{}
  async bkc_store(key, body, kw) ::
    body = this._xf_encode_body(bkc_arrbuf(body))
    let pair = await this._xf_lookup([key, body])
    return pair.stg.bkc_store(pair[0], pair[1], kw)

  async bkc_exists(key, kw) ::
    let pair = await this._xf_lookup([key])
    return pair.stg.bkc_exists(pair[0], kw)

  async bkc_fetch(key, kw) ::
    let pair = await this._xf_lookup([key])
    let body = pair.stg.bkc_fetch(pair[0], kw)
    return this._xf_decode_body(body)

