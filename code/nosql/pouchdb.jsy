import { _as_arrbuf, bkc_arrbuf } from '../core.jsy'
import { _bkc_storage_ } from '../abstract/bkc_abstract_single.jsy'

export * from '../core.jsy'

const _mode_auto = @{}
  to_attach: (arrbuf, type) => arrbuf
  from_attach: arrbuf => arrbuf


export default bkc_pouchdb
export async function bkc_pouchdb(pouchdb, opt={}) ::
  let immutable = !! opt.immutable
  let opt_path = '' + (opt.path || '/phorbas/').replace(/^\/+/, '')
  let opt_pre = opt.pre || 'phorbas-'
  let opt_ext = opt.ext || '.bkc'
  let opt_mime = opt.mime || 'application/x-phorbas+bkc'

  let {to_attach, from_attach} = opt.mode || _mode_auto

  return _bkc_storage_.with @:
    bkc_opt: @{} immutable

    async bkc_exists(hexkey) ::
      let docId = opt_path + hexkey
      let attachmentId = opt_pre + hexkey + opt_ext
      try ::
        let {_attachments} = await pouchdb.get(docId)
        return _attachments[attachmentId] ? 1 : 0
      catch err ::
        if 404 !== err.status ::
          throw err
        return 0

    async bkc_fetch(hexkey) ::
      let docId = opt_path + hexkey
      let attachmentId = opt_pre + hexkey + opt_ext
      try ::
        let res_att = _as_arrbuf @
          await pouchdb.getAttachment(docId, attachmentId)
        if null != res_att ::
          return from_attach(res_att)
      catch err ::
        if 404 !== err.status ::
          throw err

    async bkc_store(hexkey, body) ::
      let docId = opt_path + hexkey
      try ::
        var {_rev} = await pouchdb.get(docId)
        if immutable && _rev ::
          return false
      catch err ::
        if 404 !== err.status ::
          return err

      //body = new Uint8Array(await bkc_arrbuf(body))
      body = await bkc_arrbuf(body)
      let attachmentId = opt_pre + hexkey + opt_ext
      try ::
        await pouchdb.putAttachment @
          docId, attachmentId, _rev,
          to_attach(body, opt_mime), opt_mime
        return null
      catch err ::
        return err

