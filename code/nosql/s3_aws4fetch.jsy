import {bkc_hexkey_api} from '../_utils.jsy'

export default bkc_with_s3_aws4fetch
export async function bkc_with_s3_aws4fetch(aws4fetch, opt={}) ::
  if 'string' === typeof opt ::
    opt = {bucket: opt}

  const {url, bucket} = opt, base = opt.base || '', ext = opt.ext || ''
  if ! url ::
    throw new Error('opt.url required')
  if ! bucket ::
    throw new Error('opt.bucket required')

  const store_headers = opt.store_headers || null
  const _as_error = resp =>
    new Error(`s3_aws4fetch: ${resp.status}: ${resp.statusText}}`)

  return bkc_hexkey_api @:

    async hk_has(hex_key) ::
      const resp = await aws4fetch.fetch @
        new URL(`${bucket}/${base}${hex_key}${ext}`, url)
        @{} method: 'HEAD'

      if resp.ok ::
        return 1

      if 404 !== resp.status ::
        throw _as_error(resp)

      return 0


    async hk_get(hex_key) ::
      const resp = await aws4fetch.fetch @
        new URL(`${bucket}/${base}${hex_key}${ext}`, url)

      if resp.ok ::
        return new Uint8Array @
          await resp.arrayBuffer()

      if 404 !== resp.status ::
        throw _as_error(resp)


    async hk_set(hex_key, u8_content) ::
      const resp = await aws4fetch.fetch @
        new URL(`${bucket}/${base}${hex_key}${ext}`, url)

        @{} method: 'PUT',
            body: u8_content,
            headers: @{}
              ... store_headers,
              'Content-Type': 'application/octet-stream'
              'Content-Length': u8_content.byteLength
            aws: {signQuery: true}

      if ! resp.ok ::
        return _as_error(resp)

